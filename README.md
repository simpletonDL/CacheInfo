# CacheInfo
Поиск размеров L1, L2, L3 и их ассоциативность

## Подход
Наши предыдущие попытки не дали хороших результатов, поэтому мы решили поменять 
подход. Теперь мы изменяем два параметра: количество элементов для просмотра и размер шага.

1. Фиксируем шаг между элементами - `S`;
2. Фиксируем количество элементов, на которые мы будем смотреть в массиве - `R`;
3. Повторяем `factor` раз следующее действие: читаем `R` элементов с шагом `S` 

Идея в том, что определенный уровень кэша делится на блоки. Количество блоков - ассоциакивность уровня кэша.
Теперь представим, что мы находимся на определенном уровне кэша. Он имеет ассоциативность - `A`, размер `N`, 
размер блока - `M = N / A`. 
Если наш шаг(`S`) больше `M` -> мы попадаем в разные блоки. Если количество чтений(`R`) меньше `A` -> мы просто достаем значение их кэша,
а значит повторное чтение очень быстрое.

### Пример 
Пусть `A = 2`, `N = 2KB`. Если мы возьмем шаг равный `2КB`, то мы попадаем в разные блоки. 
Теперь начнем увеличивать количество просматриваемых элементов: 
1. При просмотре одного элемента - быстро, так как всегда берем элемент из блока кэша;
2. При просмотре двух элементов - быстро, так как у нас два блока, мы поочереди берем из блоков.
3. Начинаем просматривать три элемента - тут мы должны получить скачок, так как три элемента не влезают в два блока,
поэтому приходится перезаписывать элементы в кэш.

Теперь уменьшим шаг в два раза. Получаем, что мы переходим от блока к блоку через два чтения. 
Два чтения в первом блоке, два чтения во втором, опять два чтения в первом. Таким образом, мы предполагем,
что скачок произойдет при `R = 5`. Именно такой паттерн мы и ищем.

### Реализация
В файле `cacheAssoc.cpp`:

```
for stride = 8MB to 16B:
    for readCount = 1 to 34:
        // FACTOR - количество повторных чтений (1_000_000)
        loadsFixed(stride, readCount, FACTOR, ...)
```
В файле `utils.cpp`:

функция `loadsFixed(stride, readCount, FACTOR, ...)` читает `readCount` элементов, 
расстояние между которыми `stride`. Повторяет это действие `FACTOR` раз.

В итоге мы получаем csv файл с таблицей результатов. по столбцам - шаг, по строкам - 
количество элементов, на которые мы смотрим.

### Результаты
У нас пока что нет автоматического определения размеров и ассоциативности. Но глазами они отлично прослеживается.
На нашей машине:
+ L1: 32 КБ
+ L2: 256 КБ
+ L3: 16 МБ

Рассмотрим таблицу результатов.

|:D   |16   |32   |64   |128  |256  |512  |1КB  |2KB  |4KB  |8KB  |16KB |32KB |64KB |128KB|256KB|512KB|1MB  |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1|2|2|2|2|2|2|2|2|2|2|2|1|2|2|2|2|2|
|2|4|4|4|4|4|4|4|4|4|4|4|4|4|4|4|4|4|
|3|6|6|6|6|6|6|6|6|6|6|6|6|6|6|6|6|6|
|4|8|9|9|8|9|8|8|8|8|9|9|<span style="color:green">8</span>|<span style="color:red">8</span>|8|8|8|8|
|5|11|10|11|11|11|11|11|10|11|10|11|<span style="color:green">11</span>|<span style="color:red">21</span>|20|20|21|21|
|6|13|13|13|13|13|13|13|13|13|14|14|13|25|26|26|26|26|
|7|16|17|16|16|16|16|16|16|16|15|15|17|30|30|29|29|31|
|8|17|18|18|21|18|18|18|<span style="color:green">18</span>|<span style="color:red">18</span>|18|17|18|34|33|34|33|33|
|9|22|21|20|21|23|23|20|<span style="color:green">21</span>|<span style="color:red">29</span>|34|37|46|51|52|53|53|52|
|10|22|24|24|23|22|26|22|23|41|40|40|58|59|59|58|58|57|
|11|25|26|26|25|25|25|25|28|43|42|43|64|64|63|63|64|64|
|12|27|27|27|28|28|28|29|28|47|48|47|69|72|69|69|69|70|
|13|30|29|30|30|29|30|30|30|50|51|53|75|77|76|75|75|74|
|14|31|33|32|32|33|32|32|33|56|55|54|80|82|81|81|79|80|
|15|36|34|34|33|37|33|34|34|60|58|58|85|87|86|87|86|85|
|16|37|38|37|36|50|37|<span style="color:green">36</span>|<span style="color:red">37</span>|65|65|64|93|94|94|92|92|92|
|17|39|39|38|39|50|38|<span style="color:green">38</span>|<span style="color:red">50</span>|68|67|75|98|100|99|97|97|97|
|18|41|42|41|43|44|44|44|65|69|72|89|105|106|104|102|101|102|
|19|44|43|44|43|43|43|43|70|74|75|100|113|111|109|108|109|108|
|20|46|46|46|46|46|48|46|78|78|78|117|115|116|113|114|114|114|

Давайте рассмотрим первый скачок: смотрим на 16 элементов с шагом 2КБ время сопоставимо 
с меньшим количеством просматриваемых элементов. А вот при просмотре 17-ти элементов наблюдается скачок.
Заметим, что при любом шаге меньше чем 2КБ больше скачка не наблюдается.

Теперь увеличим шаг в 2 раза, тоесть уменьшаем количество просмотров в одном блоке в 2 раза. 
Мы должны получить, что скачок произойдет при количестве просмотров, которое в 2 раза меньше 16-ти -> 8. 
Полученные данные подтверждают наше предположение.

Такой же паттерн наблюдается для `(R = 8, stride = 32КБ)` и `(R = 4, stride = 64КБ)`.

Отсюда мы сделаем вывод, что ассоциативность L1 = 8, размер блока равен 4КБ, размер L1 = 8 * 4КБ = 32КБ.
Ассоциативность L2 = 4, размер блока = 64КБ, размер L2 = 256КБ. 

Для L3 почему-то данного паттерна не наблюдается, но над этим мы еще подумаем.

### TODO
Сделать автоматическое определение паттерна. 