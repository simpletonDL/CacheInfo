# Cache Line Size
Основная идея: после того, как мы определили размер (SIZE) и ассоциативность (ASSOC) кеша, мы знаем размер одной банки (M = размер кеша / ассоциативность). Дальше мы считаем милион чтений для каждого step и readCount следующим образом:

```
for (step in [1, 2, 4, 8, ...]):
    for (readCount in [1, 2, 4, 8, ...]):
        time = measurement(M + step, readCount);
```
Здесь measurement(s, r) -- функция которая делает миллион r элементов, которые расположены на расстоянии s.  

Например, для L1 кеша ASSOC = 8. Если step = 1, то при readCount <= 8 у нас не будет кеш мисов, так как каждый раз мы будем попадать в первую кеш линию каждой из банок (а банок 8 штук). Если readCount > 8, например 16, то все чтения будут все так же попадать в первую кеш линию каждой банки, но при этом на 16 элементов у нас всего свободно 8 кеш линий. Соответственно у нас будет много кеш мисов.

Пускай размер кеш линии равен 64, тогда такая же ситуация будет прослеживаться и для step = 2, 4 (будем большой скачек по времени при readCount = 16). Но при step = 8 после прочтения 8-ми элементов мы будем попадать уже не в первые кеш линии банок, а во вторые (с 9 по 16 попадаем во вторые кеш линии банок, с 17 до 24 в третьи и так далее). Поэтому скачка при step = 8 и readCount = 16 не будет. Это как раз и значит, что мы нашли кеш линию. А именно кеш линия = step * ASSOC, где step -- это первый шаг, на котором не произошло скачка при прочтении больше чем ASSOC элементов.

# CacheInfo
Поиск размеров L1, L2, L3 и их ассоциативность

## Подход
Наши предыдущие попытки не дали хороших результатов, поэтому мы решили поменять 
подход. Теперь мы изменяем два параметра: количество элементов для просмотра и размер шага.

1. Фиксируем шаг между элементами - `S` (в байтах);
2. Фиксируем количество элементов, на которые мы будем смотреть в массиве - `R`;
3. Повторяем `factor` раз следующее действие: читаем `R` элементов с шагом `S` (степень двойки) из массива размером `S * R` байт

Идея в том, что определенный уровень кэша делится на блоки. Количество блоков - ассоциативность уровня кэша.
Теперь представим, что мы находимся на определенном уровне кэша. Он имеет ассоциативность - `A`, размер `N` и
размер блока - `M = N / A`. При этом размер блока -- это всегда некоторая степеть двойки.

Если наш шаг `S` больше `M`, то `S` делится на `M`. Поэтому каждое чтение попадает в разные блоки, при этом с одним и тем же смещением внутри блока. В этом случае колчисество ячеек, которое мы можем заполнить в кеше равно ассоциативности.

Если же шаг `S` меньше `M`, то наборот `M` делится на `S`. В этом случае кол-во свободных ячеек, которые мы можем заполнить в кеше больше. Например, если `S = M/2`, то кол-во свободных ячеек равно `2 * A` (в каждом блоке по две свободных ячейки).

### Пример 
Пусть `A = 2`, `N = 2KB` => `M = 1KB`. Если мы возьмем шаг равный `1КB`, то мы попадаем в разные блоки. 
Теперь начнем увеличивать количество просматриваемых элементов: 
1. При просмотре одного элемента - быстро, так как всегда берем элемент из блока кэша;
2. При просмотре двух элементов - быстро, так как у нас два блока, мы поочереди берем из блоков.
3. Начинаем просматривать три элемента - тут мы должны получить скачок, так как три элемента не влезают в два блока,
поэтому приходится перезаписывать элементы в кэш.

Теперь уменьшим шаг в два раза (`S = 512B = M/2`). Получаем, что мы переходим от блока к блоку через два чтения. 
Два чтения в первом блоке, два чтения во втором, опять два чтения в первом. Таким образом, мы предполагем,
что скачок произойдет при `R = 5`. Именно такой паттерн мы и ищем.

### Реализация
В файле `cacheAssoc.cpp`:

```
for stride = 8MB to 16B:
    for readCount = 1 to 34:
        // FACTOR - количество повторных чтений (1_000_000)
        loadsFixed(stride, readCount, FACTOR, ...)
```
В файле `utils.cpp`:

функция `loadsFixed(stride, readCount, FACTOR, ...)` читает `readCount` элементов, 
расстояние между которыми `stride`. Повторяет это действие `FACTOR` раз.

В итоге мы получаем csv файл с таблицей результатов. по столбцам - шаг, по строкам - 
количество элементов, на которые мы смотрим.

### Результаты
У нас пока что нет автоматического определения размеров и ассоциативности. Но глазами они отлично прослеживается.
На нашей машине:
+ L1: 32 КБ
+ L2: 256 КБ
+ L3: 16 МБ

Рассмотрим таблицу результатов.

|:D   |16   |32   |64   |128  |256  |512  |1КB  |2KB  |4KB  |8KB  |16KB |32KB |64KB |128KB|256KB|512KB|1MB  |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1|2|2|2|2|2|2|2|2|2|2|2|1|2|2|2|2|2|
|2|4|4|4|4|4|4|4|4|4|4|4|4|4|4|4|4|4|
|3|6|6|6|6|6|6|6|6|6|6|6|6|6|6|6|6|6|
|4|8|9|9|8|9|8|8|8|8|9|9|`8`|`8`|8|8|8|8|
|5|11|10|11|11|11|11|11|10|11|10|11|`11`|`21`|20|20|21|21|
|6|13|13|13|13|13|13|13|13|13|14|14|13|25|26|26|26|26|
|7|16|17|16|16|16|16|16|16|16|15|15|17|30|30|29|29|31|
|8|17|18|18|21|18|18|18|`18`|`18`|18|17|18|34|33|34|33|33|
|9|22|21|20|21|23|23|20|`21`|`29`|34|37|46|51|52|53|53|52|
|10|22|24|24|23|22|26|22|23|41|40|40|58|59|59|58|58|57|
|11|25|26|26|25|25|25|25|28|43|42|43|64|64|63|63|64|64|
|12|27|27|27|28|28|28|29|28|47|48|47|69|72|69|69|69|70|
|13|30|29|30|30|29|30|30|30|50|51|53|75|77|76|75|75|74|
|14|31|33|32|32|33|32|32|33|56|55|54|80|82|81|81|79|80|
|15|36|34|34|33|37|33|34|34|60|58|58|85|87|86|87|86|85|
|16|37|38|37|36|50|37|`36`|`37`|65|65|64|93|94|94|92|92|92|
|17|39|39|38|39|50|38|`38`|`50`|68|67|75|98|100|99|97|97|97|
|18|41|42|41|43|44|44|44|65|69|72|89|105|106|104|102|101|102|
|19|44|43|44|43|43|43|43|70|74|75|100|113|111|109|108|109|108|
|20|46|46|46|46|46|48|46|78|78|78|117|115|116|113|114|114|114|

Давайте рассмотрим первый скачок: смотрим на 16 элементов с шагом 2КБ время сопоставимо 
с меньшим количеством просматриваемых элементов. А вот при просмотре 17-ти элементов наблюдается скачок.
Заметим, что при любом шаге меньше чем 2КБ больше скачка не наблюдается.

Теперь увеличим шаг в 2 раза, тоесть уменьшаем количество просмотров в одном блоке в 2 раза. 
Мы должны получить, что скачок произойдет при количестве просмотров, которое в 2 раза меньше 16-ти -> 8. 
Полученные данные подтверждают наше предположение.

Такой же паттерн наблюдается для `(R = 8, stride = 32КБ)` и `(R = 4, stride = 64КБ)`.

Отсюда мы сделаем вывод, что ассоциативность L1 = 8, размер блока равен 4КБ, размер L1 = 8 * 4КБ = 32КБ.
Ассоциативность L2 = 4, размер блока = 64КБ, размер L2 = 256КБ. 

Для L3 почему-то данного паттерна не наблюдается, но над этим мы еще подумаем.

### TODO
Сделать автоматическое определение паттерна.
